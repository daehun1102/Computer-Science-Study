<br>

# 운영체제 총정리

운영체제(OS)의 존재 이유는 컴퓨터 자원을 **효율적이고 형평성 있게 관리**하는 것이다. <br>
운영체제의 역할과 구조, 컴퓨터 자원에 대해 자세히 알아보고, <br>
메모리 관리 방식, CPU 관리 방식엔 어떤게 있고 어떻게 동작하는지 알아보자.

<br>

## 운영체제의 네 가지 역할

운영체제는 컴퓨터 자원의 효율적 관리를 위해 다음과 같은 네 가지 역할을 수행한다.

| 역할                             | 설명                                                                                                                              |
| :------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| **CPU 스케줄링과 프로세스 관리** | CPU 자원을 프로세스들에게 **형평성있고 효율적으로 분배**하며, 프로세스의 생성, 실행, 종료 및 상태를 관리한다.                     |
| **메모리 관리**                  | 한정된 메모리 공간을 여러 프로세스가 효율적으로 사용하도록 할당 및 회수하며, **가상 주소**와 **물리 주소**를 MMU를 통해 관리한다. |
| **디스크 파일 관리**             | 디스크에 저장된 데이터를 파일 단위로 관리하며, **데이터의 저장, 접근, 보호** 등을 담당한다.                                       |
| **I/O 디바이스 관리**            | 키보드, 마우스, 프린터 등 **입출력 장치**에 대한 접근 및 작동을 제어하고 관리한다.                                                |

<br>

## 운영체제의 구조

운영체제는 사용자의 안전한 자원 접근을 보장하고 기능을 수행하기 위해 **시스템 콜**과 **커널** 구조를 갖는다.

### 1. 시스템 콜 (System Call)

- **정의:** 유저 프로그램이 운영체제, 즉 **커널**에 접근하여 서비스를 요청하기 위한 **인터페이스**이다.
- **Modebit:** 시스템 콜 작동 시, **유저 모드 (1)** 와 **커널 모드 (0)** 를 구분하는 플래그 변수이다.
  - **커널 모드**일 때만 **I/O 디바이스**와 같은 중요한 컴퓨터 자원에 접근이 허용되어 자원을 안전하게 관리한다.

### 2. 커널 (Kernel)

- **정의:** 운영체제의 **본체**로, 메모리(주기억장치)에 상주하며 컴퓨터 자원 관리를 담당하는 부분.
- **역할:** 커널 영역과 사용자 영역을 분리하여 자원에 대한 무분별한 접근을 막고 **안전성**을 보장한다.

<br>

## 컴퓨터 자원 (관리 대상)

운영체제가 관리하는 주요 컴퓨터 자원에는 **CPU**, **메모리 계층**, **입출력 장치** 등이 있다.

### 1. CPU (Central Processing Unit)

- **구성:** **산술 논리 연산 장치(ALU)**, **제어 장치**, **레지스터**로 구성된다.
  - **제어 장치:** 명령어의 실행 순서를 결정한다.
  - **레지스터:** 데이터를 임시로 저장한다.
  - **산술 논리 연산 장치:** 논리 및 산술 연산을 수행한다.
- **역할:** 메모리(RAM)에 올라와 **프로세스**가 된 프로그램의 **명령어를 해석하고 실행**한다.
- **인터럽트:** CPU를 잠깐 정지시키는 신호로, I/O 작업 완료 등 특정 상황 발생을 알린다.

### 2. 메모리 계층 구조

컴퓨터의 메모리는 **계층적인 구조**를 지니며, 위로 갈수록 **용량은 작아지지만 속도는 빨라**진다. 이는 **성능과 경제성**을 모두 고려한 결과이다.

| 종류                        | 위치/특징                   | 용량      | 속도      | 역할                                                      |
| :-------------------------- | :-------------------------- | :-------- | :-------- | :-------------------------------------------------------- |
| **레지스터**                | CPU 내부의 가장 작은 메모리 | 매우 작음 | 매우 빠름 | 명령어 처리 시 데이터 임시 저장                           |
| **캐시** (L1, L2, L3)       | CPU와 주기억장치 사이       | 작음      | 빠름      | 자주 쓰는 데이터의 **임시 보관소**                        |
| **주기억장치** (RAM)        | 메인 메모리                 | 보통      | 보통      | 프로그램을 올려 **프로세스**로 만들어 CPU가 처리하도록 함 |
| **보조기억장치** (HDD, SSD) | 저장 장치                   | 매우 큼   | 느림      | 프로그램 및 데이터를 **영구적으로 저장**                  |

#### 캐시 (Cache) 상세

- **필요성:** CPU와 주기억장치 간의 속도 차이로 인한 **시간 지연을 줄이기 위함**이다.
- **지역성:** '자주 불러온다'의 기준이며 두 가지가 있다.
  - **시간 지역성:** 최근에 사용한 데이터는 곧 다시 사용될 가능성이 높음.
  - **공간 지역성:** 최근에 접근한 데이터 주변의 데이터는 곧 사용될 가능성이 높음.
- **캐시 히트/미스:**
  - **캐시 히트:** 캐시에서 원하는 데이터를 찾은 경우.
  - **캐시 미스:** 캐시에 데이터가 없어 주 메모리에서 데이터를 찾아오는 경우.
- **캐시 매핑:** 캐시가 히트되기 위해 주 메모리 주소와 캐시 주소 간의 대응 관계를 설정하는 방법이다 (직접 매핑, 연관 매핑, 집합 연관 매핑 등).

<br>

## 메모리 관리 방식

### 가상 주소와 물리 주소

운영체제가 메모리를 관리할 때는 물리 주소와 가상 주소라는 두 가지 주소 체계를 사용한다.

물리 주소 (Physical Address): 실제 메모리(RAM) 칩 상에 존재하는 하드웨어 고유의 주소이다. CPU가 최종적으로 접근해야 할 실제 위치이다.

가상 주소 (Virtual Address): 프로세스가 실행될 때 참조하는 논리적인 주소이다. 각 프로세스는 다른 프로세스와 격리된 자신만의 독립적인 주소 공간(0번지부터 시작하는)을 할당받는다.

운영체제는 메모리를 효율적으로 사용하기 위해 **연속 할당 방식**과 **불연속 할당 방식**을 사용한다.

### 1. 연속 할당 방식 (Contiguous Allocation)

메모리 공간에 프로세스를 **연속적으로** 할당한다.

- **고정 분할 방식:** 메모리를 미리 나누어 관리하며, 융통성이 없어 **내부 단편화** (할당된 공간 내 남는 공간)가 발생한다.
- **가변 분할 방식:** 프로그램 크기에 따라 동적으로 나누며, **외부 단편화** (총합은 충분하나 연속되지 않은 남는 공간)가 발생할 수 있다.

### 2. 불연속 할당 방식 (Non-Contiguous Allocation)

메모리 공간에 프로세스를 **불연속적으로** 할당하여 외부 단편화 문제를 해결한다.

- **페이징 (Paging):** 프로세스를 동일 크기의 **페이지** 단위로 나누어 메모리의 서로 다른 위치에 할당하며, **페이지 테이블**로 매핑 정보를 관리한다.
- **세그멘테이션 (Segmentation):** 프로세스를 의미 단위인 **세그먼트**로 나누어 할당한다.

### 3. 페이지 교체 알고리즘

한정된 메모리에서 스와핑이 잦아지는 것을 막기 위해, 교체 대상 페이지를 선정하는 알고리즘이다.

- **FIFO (First-In, First-Out):** 가장 먼저 메모리에 들어온 페이지를 가장 먼저 내보낸다.
- **LRU (Least Recently Used):** **가장 오랫동안 사용되지 않은** 페이지를 내보낸다.
- **LFU (Least Frequently Used):** **가장 참조 횟수가 적은** 페이지를 내보낸다.

<br>

## 프로세스 및 스레드

### 1. 프로세스와 스레드의 개념

- **프로세스 (Process):** 프로그램이 메모리 위에 올라가 **실행 중**인 인스턴스이다. 운영체제에 의해 **독립적인 메모리 공간과 시스템 자원**을 할당받는다.
- **스레드 (Thread):** 프로세스 내부에서 작업을 처리하는 **가장 작은 실행 단위**이다. 프로세스 내의 자원(코드, 데이터, 힙 영역)을 **공유**하여 동시성 및 효율성을 높인다.

### 2. 프로세스 상태

프로세스의 생명 주기 동안 다음과 같은 상태 변화가 발생한다.

| 상태           | 설명                                                          |
| :------------- | :------------------------------------------------------------ |
| **New**        | 프로세스가 생성되며, 이때 **PCB**가 할당된다.                 |
| **Ready**      | CPU 소유권이 할당되기를 기다리는 상태이다.                    |
| **Running**    | CPU 소유권을 할당받아 명령어를 수행 중인 상태이다.            |
| **Waiting**    | I/O 입출력 처리 등 특정 이벤트 완료를 대기하는 상태이다.      |
| **Terminated** | 실행을 완료하고 메모리와 CPU 소유권을 모두 해제하는 상태이다. |

### 3. 프로세스 메모리 구조

프로세스는 **정적 영역**과 **동적 영역**으로 구성된 메모리 구조를 갖는다.

| 영역            | 구분 | 저장 내용                                         |
| :-------------- | :--- | :------------------------------------------------ |
| **코드 영역**   | 정적 | 기계어인 실행 코드가 저장되는 영역                |
| **데이터 영역** | 정적 | 전역 변수나 정적 변수가 저장되는 영역             |
| **스택 영역**   | 동적 | 함수 호출 정보와 지역 변수가 저장되는 영역 (LIFO) |
| **힙 영역**     | 동적 | 동적으로 메모리를 할당하거나 해제하는 영역        |

### 4. PCB (Process Control Block)

- **정의:** 운영체제가 **프로세스에 대한 모든 정보를 저장**하는 데이터 구조이다.
- **활용:** **Context Switching** 발생 시 이전 프로세스의 정보를 저장하고 새로운 프로세스의 정보를 복원하는 데 쓰인다.
- **주요 정보:** 프로세스 ID, 스케줄링 상태, 프로그램 카운터 (다음에 실행할 명령어 주소), CPU 레지스터 값 등.

### 5. Context Switching (문맥 교환)

- **정의:** 현재 실행 중인 프로세스의 **CPU 제어권을 다른 프로세스로 전환**하는 과정이다.  
  운영체제는 기존 프로세스의 실행 상태를 PCB에 저장하고, 새 프로세스의 PCB 정보를 복원하여 CPU가 이어서 실행하도록 한다.

- **필요성:** 한정된 CPU 자원을 여러 프로세스가 **공평하게 사용**하기 위해 반드시 필요한 과정이다.

- **작동 순서:**

  1. 현재 실행 중인 프로세스의 레지스터 값, 프로그램 카운터 등을 PCB에 저장
  2. 새롭게 스케줄된 프로세스의 PCB 정보를 읽어 레지스터에 복원
  3. CPU 제어권을 새 프로세스로 넘겨 실행 재개

- **발생 시점 :**

  - **타임 슬라이스(Time Slice)** 종료 시 (라운드 로빈 스케줄링)
  - **I/O 요청**으로 CPU가 비워졌을 때
  - **우선순위가 더 높은 프로세스**가 도착했을 때
  - **시스템 콜**이나 **인터럽트**가 발생했을 때

- **오버헤드:**  
  문맥 교환에는 **PCB 저장·복원, 캐시 초기화, 메모리 매핑 갱신** 등의 작업이 포함되어 CPU 시간이 소모된다.  
  따라서 **문맥 교환 횟수가 많아지면 시스템 성능이 저하**될 수 있다.

### 6. 멀티프로세스 vs 멀티스레드

- **멀티프로세스:** 두 개 이상의 **독립적인 프로세스**가 병렬적으로 처리된다. **IPC**를 통해서만 데이터를 공유할 수 있으며 오버헤드가 크다.
- **멀티스레드:** 하나의 프로세스 내에서 여러 **스레드**가 병렬적으로 작업을 처리한다. 스택 영역을 제외한 자원을 공유하므로 데이터 공유가 용이하여 더 효율적이다.

#### IPC (Inter Process Communication)

**프로세스끼리 데이터를 공유**하는 기술이다.

- **공유 메모리:** 메모리 영역을 공유하여 직접 접근하는 방식. 동기화가 필요하지만 성능이 뛰어나다.
- **소켓:** 네트워크 인터페이스를 통한 데이터 전송.
- **파이프 (익명/명명):** 파이프(임시 공간)를 통해 데이터를 주고받는다. 익명은 부모-자식 간 통신, 명명은 관계없는 프로세스 간 통신이 가능하다.
- **메시지 큐:** 메시지를 큐 형태로 관리하여 통신한다.

---

## CPU 스케줄링 알고리즘

CPU 스케줄링은 운영체제가 프로세스들에게 **형평적이고 효율적으로** CPU 자원을 분배하기 위한 스케줄 작성이다. 프로세스의 상태를 보고 동적으로 스케줄링해야 한다.

### 1. 선점 스케줄링 (Preemptive)

CPU가 한 프로세스의 처리를 다 끝내기 **전**에 다른 프로세스로 전환(선점)할 수 있다. 응답 시간 보장에 유리하다.

- **라운드 로빈 (Round Robin, RR):** 각 프로세스에 동일한 할당 시간(Time Slice)을 주고 그 시간 내에만 처리한다. **공평한 응답 시간**을 제공하여 현대 컴퓨터에 가장 많이 쓰인다.
- **SRF (Shortest Remaining First):** SJF의 선점형 버전으로, 실행 중인 프로세스보다 **남은 실행 시간이 더 짧은** 새 프로세스가 들어오면 중단하고 이동한다.
- **다단계 큐 (Multilevel Queue):** 여러 개의 큐를 두고 우선순위를 나누어 큐마다 다른 스케줄링 알고리즘을 적용할 수 있다.

### 2. 비선점 스케줄링 (Non-Preemptive)

CPU를 할당받은 프로세스가 작업을 **완료**하거나 **자발적으로** CPU를 놓을 때까지 다른 프로세스가 CPU를 사용할 수 없다. 오버헤드가 줄어든다.

- **FCFS (First-Come, First-Served):** 먼저 들어온 프로세스부터 순서대로 처리한다.
- **SJF (Shortest Job First):** **실행 시간이 가장 짧은** 프로세스부터 처리한다. 평균 응답 시간은 짧으나, 긴 프로세스가 무한정 대기하는 **Starvation** 현상이 발생할 수 있다.
- **우선순위 스케줄링:** 프로세스마다 우선순위를 부여하여 높은 순위부터 처리한다. **Aging (노화)** 기법을 통해 Starvation을 방지한다.

<br>

## 병행 제어 (Concurrency Control)

운영체제는 여러 프로세스와 스레드가 **공유 자원에 동시에 접근**할 때, 데이터의 일관성을 유지하기 위해 다양한 동기화 기법을 사용한다.

### 1. 경쟁 상태 (Race Condition)

- **정의:** 두 개 이상의 프로세스나 스레드가 **공유 자원에 동시에 접근**하여,  
  실행 순서에 따라 결과가 달라지는 상황이다.
- **예시:** 두 개의 스레드가 동시에 변수 `count`를 1 증가시키면, 최종 결과가 1만 증가하거나 2만 증가할 수 있다.
- **문제점:** 데이터 무결성이 깨지고, 프로그램의 동작이 예측 불가능해진다.

---

### 2. 임계 구역 (Critical Section)

- **정의:** 둘 이상의 프로세스가 동시에 접근해서는 안 되는 **공유 자원 접근 코드 영역**이다.
- **문제점:** 한 스레드가 임계 구역을 실행 중일 때, 다른 스레드가 같은 영역에 들어오면 **데이터 불일치**가 발생한다.
- **해결 원칙 (3대 조건):**
  1. **상호 배제 (Mutual Exclusion):** 한 번에 하나의 프로세스만 임계 구역에 접근 가능해야 한다.
  2. **진행 (Progress):** 임계 구역에 아무도 없는 경우, 접근을 원하는 프로세스가 즉시 들어갈 수 있어야 한다.
  3. **한정 대기 (Bounded Waiting):** 특정 프로세스가 무한정 대기하지 않아야 한다 (Starvation 방지).

---

### 3. 동기화 도구

#### (1) 뮤텍스 (Mutex, Mutual Exclusion)

- **정의:** 한 번에 **하나의 스레드만 임계 구역에 들어갈 수 있도록 잠금(Lock)을 설정**하는 방식이다.
- **특징:**
  - 잠금을 걸면(lock) 다른 스레드는 대기해야 한다.
  - 해당 스레드가 작업을 끝내면 **unlock**을 통해 잠금을 해제한다.
- **비유:** 화장실 문을 잠그고 들어가는 것처럼 한 명만 들어갈 수 있음.

#### (2) 세마포어 (Semaphore)

- **정의:** 접근 가능한 **프로세스의 개수를 제어**하는 동기화 도구이다.
- **변수:** 세마포어 값 `S`는 현재 접근 가능한 자원의 개수를 의미한다.
  - **Wait(P) 연산:** `S`를 1 감소시키며, 0보다 작으면 대기.
  - **Signal(V) 연산:** `S`를 1 증가시켜 대기 중인 프로세스를 깨운다.
- **종류:**
  | 구분 | 의미 | 예시 |
  | :-- | :-- | :-- |
  | **이진 세마포어** | 0 또는 1 값만 가능 (뮤텍스처럼 작동함) | 임계 구역 보호 |
  | **카운팅 세마포어** | 2 이상 가능 (공유 자원 여러 개 관리) | 프린터, 버퍼 등 |

---

### 4. 교착 상태 (Deadlock)

- **정의:** 두 개 이상의 프로세스가 서로 자원을 점유한 채,  
  **상대방이 가진 자원을 기다리면서 무한히 대기**하는 상태이다.

#### (1) 발생 조건 (4가지 모두 만족 시 교착 상태 발생)

| 조건                             | 설명                                               |
| :------------------------------- | :------------------------------------------------- |
| **상호 배제 (Mutual Exclusion)** | 한 번에 한 프로세스만 자원을 사용할 수 있다.       |
| **점유 대기 (Hold and Wait)**    | 한 자원을 점유한 채 다른 자원을 요청하며 대기한다. |
| **비선점 (No Preemption)**       | 자원을 강제로 빼앗을 수 없다.                      |
| **환형 대기 (Circular Wait)**    | 프로세스들이 서로의 자원을 순환적으로 기다린다.    |

#### (2) 교착 상태의 해결 방법

| 방식                  | 설명                                                                              |
| :-------------------- | :-------------------------------------------------------------------------------- |
| **예방 (Prevention)** | 위 4가지 조건 중 하나 이상이 발생하지 않도록 시스템을 설계한다.                   |
| **회피 (Avoidance)**  | 자원 할당 시 교착 상태 가능성을 미리 계산하여 피한다 (예: Banker's Algorithm).    |
| **탐지 (Detection)**  | 주기적으로 시스템을 검사해 교착 상태를 탐지하고, 교착된 프로세스를 강제 종료한다. |
| **복구 (Recovery)**   | 교착 상태가 발생한 후, 관련 프로세스를 종료하거나 자원을 회수한다.                |

---
